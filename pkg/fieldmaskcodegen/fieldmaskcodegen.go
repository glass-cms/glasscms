package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

// TODO: Add support for nested structs.

// Template for the generated validation function.
const validateTemplate = `// Code generated by field mask validation generator; DO NOT EDIT.

package {{ .PackageName }}

import "errors"

var ErrInvalid{{ .StructName }}Field = errors.New("invalid field")

// Validate{{ .StructName }}FieldMask validates a field mask for the {{ .StructName }} struct
func Validate{{ .StructName }}FieldMask(fieldmask []string) error {
	validFields := map[string]struct{}{
	{{- range .Fields }}
		"{{ . }}": {},
	{{- end }}
	}

	for _, field := range fieldmask {
		if _, exists := validFields[field]; !exists {
			return ErrInvalid{{ .StructName }}Field
		}
	}
	return nil
}
`

// TemplateData holds data for the code generation template.
type TemplateData struct {
	PackageName string
	StructName  string
	Fields      []string
}

//nolint:gocognit // This is a code generation tool, so it's expected to be complex.
func main() {
	structName := flag.String("type", "", "The name of the struct to generate validation for")
	output := flag.String("output", "", "output file name; default srcdir/<type>_validate.go")
	flag.Parse()

	if *structName == "" {
		log.Fatalf("Error: struct type not specified")
	}

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo,
	}
	pkgs, err := packages.Load(cfg, ".")
	if err != nil {
		log.Fatal(err)
	}

	// Process each package and look for the struct type
	for _, pkg := range pkgs {
		for _, syntax := range pkg.Syntax {
			ast.Inspect(syntax, func(n ast.Node) bool {
				// Look for type declarations
				genDecl, ok := n.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					return true
				}

				for _, spec := range genDecl.Specs {
					typeSpec, isTypeSpecValid := spec.(*ast.TypeSpec)
					if !isTypeSpecValid {
						continue
					}

					// If the type matches the requested struct name, generate code.
					if typeSpec.Name.Name == *structName {
						if structType, isStructType := typeSpec.Type.(*ast.StructType); isStructType {
							generateValidationCode(pkg.Name, *structName, structType, *output)
						}
					}
				}
				return true
			})
		}
	}
}

// generateValidationCode generates the validation function for the given struct type.
func generateValidationCode(packageName, structName string, structType *ast.StructType, outputFile string) {
	// Extract field names and JSON tags
	fields := extractFields(structType)
	fmt.Println("Fields:", fields)

	// Prepare the template data
	data := TemplateData{
		PackageName: packageName,
		StructName:  structName,
		Fields:      fields,
	}

	// Create the file for the generated code
	if outputFile == "" {
		outputFile = fmt.Sprintf("%s_validate.go", strings.ToLower(structName))
	}
	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Error creating output file: %v", err)
	}
	defer f.Close()

	// Parse and execute the template
	tmpl := template.Must(template.New("validateTemplate").Parse(validateTemplate))
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, data)
	if err != nil {
		log.Printf("Error executing template: %v", err)
	}

	// Format the generated code
	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Println("Error formatting source code: %w", err)
	}

	// Write the formatted source to the file
	_, err = f.Write(src)
	if err != nil {
		log.Println("Error writing to output file: %w", err)
	}
}

// extractFields extracts the field names (and JSON tags) from a struct.
func extractFields(structType *ast.StructType) []string {
	var fields []string
	for _, field := range structType.Fields.List {
		jsonTag := getJSONTag(field)
		if jsonTag != "" {
			fields = append(fields, jsonTag)
		}
	}
	return fields
}

// getJSONTag extracts the JSON tag from a struct field's tag, if present.
func getJSONTag(field *ast.Field) string {
	if field.Tag == nil {
		return ""
	}
	tag := field.Tag.Value
	tag = strings.Trim(tag, "`") // Remove backticks
	parts := strings.Split(tag, " ")
	for _, part := range parts {
		if strings.HasPrefix(part, "json:") {
			jsonTag := strings.Trim(part[5:], "\"")
			// Remove ",omitempty" if present
			if idx := strings.Index(jsonTag, ",omitempty"); idx != -1 {
				jsonTag = jsonTag[:idx]
			}
			return jsonTag
		}
	}
	return ""
}
